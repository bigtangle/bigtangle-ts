// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.20.3
// source: src/wallet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "wallet";

export interface PeerAddress {
  ipAddress: Uint8Array;
  port: number;
  services: number;
}

export interface EncryptedData {
  /** The initialisation vector for the AES encryption (16 bytes) */
  initialisationVector: Uint8Array;
  /** The encrypted private key */
  encryptedPrivateKey: Uint8Array;
}

/** Data attached to a Key message that defines the data needed by the BIP32 deterministic key hierarchy algorithm. */
export interface DeterministicKey {
  /**
   * Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
   * should just treat it as a regular ORIGINAL type key.
   */
  chainCode: Uint8Array;
  /**
   * The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
   * and high bit unset for public derivation.
   */
  path: number[];
  /**
   * How many children of this key have been issued, that is, given to the user when they requested a fresh key?
   * For the parents of keys being handed out, this is always less than the true number of children: the difference is
   * called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
   * this wallet - for instance when restoring from backup or if the seed was shared between devices.
   *
   * If this field is missing it means we're not issuing subkeys of this key to users.
   */
  issuedSubkeys?: number | undefined;
  lookaheadSize?:
    | number
    | undefined;
  /**
   * Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
   * Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
   * a single P2SH multisignature address
   */
  isFollowing?:
    | boolean
    | undefined;
  /**
   * Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
   * and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
   */
  sigsRequiredToSpend?: number | undefined;
}

/**
 * A key used to control Bitcoin spending.
 *
 * Either the private key, the public key or both may be present.  It is recommended that
 * if the private key is provided that the public key is provided too because deriving it is slow.
 *
 * If only the public key is provided, the key can only be used to watch the blockchain and verify
 * transactions, and not for spending.
 */
export interface Key {
  type: Key_Type;
  /**
   * Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
   * If the secret is encrypted, or this is a "watching entry" then this is missing.
   */
  secretBytes?:
    | Uint8Array
    | undefined;
  /** If the secret data is encrypted, then secret_bytes is missing and this field is set. */
  encryptedData?:
    | EncryptedData
    | undefined;
  /**
   * The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
   * do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
   */
  publicKey?:
    | Uint8Array
    | undefined;
  /** User-provided label associated with the key. */
  label?:
    | string
    | undefined;
  /**
   * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. The reason it's
   * optional is that keys derived from a parent don't have this data.
   */
  creationTimestamp?: number | undefined;
  deterministicKey?:
    | DeterministicKey
    | undefined;
  /**
   * The seed for a deterministic key hierarchy.  Derived from the mnemonic,
   * but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
   */
  deterministicSeed?:
    | Uint8Array
    | undefined;
  /** Encrypted version of the seed */
  encryptedDeterministicSeed?: EncryptedData | undefined;
}

export enum Key_Type {
  /** ORIGINAL - Unencrypted - Original bitcoin secp256k1 curve */
  ORIGINAL = 1,
  /** ENCRYPTED_SCRYPT_AES - Encrypted with Scrypt and AES - Original bitcoin secp256k1 curve */
  ENCRYPTED_SCRYPT_AES = 2,
  /**
   * DETERMINISTIC_MNEMONIC - Not really a key, but rather contains the mnemonic phrase for a deterministic key hierarchy in the private_key field.
   * The label and public_key fields are missing. Creation timestamp will exist.
   */
  DETERMINISTIC_MNEMONIC = 3,
  /**
   * DETERMINISTIC_KEY - A key that was derived deterministically. Note that the root seed that created it may NOT be present in the
   * wallet, for the case of watching wallets. A deterministic key may or may not have the private key bytes present.
   * However the public key bytes and the deterministic_key field are guaranteed to exist. In a wallet where there
   * is a path from this key up to a key that has (possibly encrypted) private bytes, it's expected that the private
   * key can be rederived on the fly.
   */
  DETERMINISTIC_KEY = 4,
  UNRECOGNIZED = -1,
}

export function key_TypeFromJSON(object: any): Key_Type {
  switch (object) {
    case 1:
    case "ORIGINAL":
      return Key_Type.ORIGINAL;
    case 2:
    case "ENCRYPTED_SCRYPT_AES":
      return Key_Type.ENCRYPTED_SCRYPT_AES;
    case 3:
    case "DETERMINISTIC_MNEMONIC":
      return Key_Type.DETERMINISTIC_MNEMONIC;
    case 4:
    case "DETERMINISTIC_KEY":
      return Key_Type.DETERMINISTIC_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Key_Type.UNRECOGNIZED;
  }
}

export function key_TypeToJSON(object: Key_Type): string {
  switch (object) {
    case Key_Type.ORIGINAL:
      return "ORIGINAL";
    case Key_Type.ENCRYPTED_SCRYPT_AES:
      return "ENCRYPTED_SCRYPT_AES";
    case Key_Type.DETERMINISTIC_MNEMONIC:
      return "DETERMINISTIC_MNEMONIC";
    case Key_Type.DETERMINISTIC_KEY:
      return "DETERMINISTIC_KEY";
    case Key_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Script {
  program: Uint8Array;
  /**
   * Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
   * when watching for scripts on the blockchain.
   */
  creationTimestamp: number;
}

export interface TransactionInput {
  /** Hash of the transaction this input is using. */
  transactionOutPointHash: Uint8Array;
  /** Index of transaction output used by this input. */
  transactionOutPointIndex: number;
  /** Script that contains the signatures/pubkeys. */
  scriptBytes: Uint8Array;
  /** Sequence number. */
  sequence?:
    | number
    | undefined;
  /** Value of connected output, if known */
  value?: number | undefined;
}

export interface TransactionOutput {
  value: number;
  tokenid: number;
  /** script of transaction output */
  scriptBytes: Uint8Array;
  /** If spent, the hash of the transaction doing the spend. */
  spentByTransactionHash?:
    | Uint8Array
    | undefined;
  /** If spent, the index of the transaction input of the transaction doing the spend. */
  spentByTransactionIndex?: number | undefined;
}

/**
 * A description of the confidence we have that a transaction cannot be reversed in the future.
 *
 * Parsing should be lenient, since this could change for different applications yet we should
 * maintain backward compatibility.
 */
export interface TransactionConfidence {
  /** This is optional in case we add confidence types to prevent parse errors - backwards compatible. */
  type?:
    | TransactionConfidence_Type
    | undefined;
  /** If type == BUILDING then this is the chain height at which the transaction was included. */
  appearedAtHeight?:
    | number
    | undefined;
  /**
   * If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
   * multiple transactions in the case of several inputs being re-spent by several transactions but we don't
   * bother to track them all, just the first. This only makes sense if type = DEAD.
   */
  overridingTransaction?:
    | Uint8Array
    | undefined;
  /**
   * If type == BUILDING then this is the depth of the transaction in the blockchain.
   * Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
   */
  depth?: number | undefined;
  broadcastBy: PeerAddress[];
  /** Millis since epoch the transaction was last announced to us. */
  lastBroadcastedAt?: number | undefined;
  source?: TransactionConfidence_Source | undefined;
}

export enum TransactionConfidence_Type {
  /** UNKNOWN - See TransactionConfidence.java for a more thorough explanation of these types. */
  UNKNOWN = 0,
  /** BUILDING - In best chain.  If and only if appeared_at_height is present. */
  BUILDING = 1,
  /** PENDING - Unconfirmed and sitting in the networks memory pools, waiting to be included in the chain. */
  PENDING = 2,
  /** NOT_IN_BEST_CHAIN - Deprecated: equivalent to PENDING. */
  NOT_IN_BEST_CHAIN = 3,
  /** DEAD - Either if overriding_transaction is present or transaction is dead coinbase. */
  DEAD = 4,
  /** IN_CONFLICT - There is another transaction spending one of this transaction inputs. */
  IN_CONFLICT = 5,
  UNRECOGNIZED = -1,
}

export function transactionConfidence_TypeFromJSON(object: any): TransactionConfidence_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TransactionConfidence_Type.UNKNOWN;
    case 1:
    case "BUILDING":
      return TransactionConfidence_Type.BUILDING;
    case 2:
    case "PENDING":
      return TransactionConfidence_Type.PENDING;
    case 3:
    case "NOT_IN_BEST_CHAIN":
      return TransactionConfidence_Type.NOT_IN_BEST_CHAIN;
    case 4:
    case "DEAD":
      return TransactionConfidence_Type.DEAD;
    case 5:
    case "IN_CONFLICT":
      return TransactionConfidence_Type.IN_CONFLICT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionConfidence_Type.UNRECOGNIZED;
  }
}

export function transactionConfidence_TypeToJSON(object: TransactionConfidence_Type): string {
  switch (object) {
    case TransactionConfidence_Type.UNKNOWN:
      return "UNKNOWN";
    case TransactionConfidence_Type.BUILDING:
      return "BUILDING";
    case TransactionConfidence_Type.PENDING:
      return "PENDING";
    case TransactionConfidence_Type.NOT_IN_BEST_CHAIN:
      return "NOT_IN_BEST_CHAIN";
    case TransactionConfidence_Type.DEAD:
      return "DEAD";
    case TransactionConfidence_Type.IN_CONFLICT:
      return "IN_CONFLICT";
    case TransactionConfidence_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Where did we get this transaction from? Knowing the source may help us to risk analyze pending transactions. */
export enum TransactionConfidence_Source {
  /** SOURCE_UNKNOWN - We don't know where it came from, or this is a wallet from the future. */
  SOURCE_UNKNOWN = 0,
  /** SOURCE_NETWORK - We received it from a network broadcast. This is the normal way to get payments. */
  SOURCE_NETWORK = 1,
  /** SOURCE_SELF - We made it ourselves, so we know it should be valid. */
  SOURCE_SELF = 2,
  UNRECOGNIZED = -1,
}

export function transactionConfidence_SourceFromJSON(object: any): TransactionConfidence_Source {
  switch (object) {
    case 0:
    case "SOURCE_UNKNOWN":
      return TransactionConfidence_Source.SOURCE_UNKNOWN;
    case 1:
    case "SOURCE_NETWORK":
      return TransactionConfidence_Source.SOURCE_NETWORK;
    case 2:
    case "SOURCE_SELF":
      return TransactionConfidence_Source.SOURCE_SELF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionConfidence_Source.UNRECOGNIZED;
  }
}

export function transactionConfidence_SourceToJSON(object: TransactionConfidence_Source): string {
  switch (object) {
    case TransactionConfidence_Source.SOURCE_UNKNOWN:
      return "SOURCE_UNKNOWN";
    case TransactionConfidence_Source.SOURCE_NETWORK:
      return "SOURCE_NETWORK";
    case TransactionConfidence_Source.SOURCE_SELF:
      return "SOURCE_SELF";
    case TransactionConfidence_Source.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction {
  /** See Wallet.java for detailed description of pool semantics */
  version: number;
  hash: Uint8Array;
  /**
   * If pool is not present, that means either:
   *  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
   *  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
   *  - Or the Pool enum got a new value which your software is too old to parse.
   */
  pool?:
    | Transaction_Pool
    | undefined;
  /** The nLockTime field is useful for contracts. */
  lockTime?:
    | number
    | undefined;
  /** millis since epoch the transaction was last updated */
  updatedAt?: number | undefined;
  transactionInput: TransactionInput[];
  transactionOutput: TransactionOutput[];
  /**
   * A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
   * ordering within a block.
   */
  blockHash: Uint8Array[];
  blockRelativityOffsets: number[];
  /** Data describing where the transaction is in the chain. */
  confidence?: TransactionConfidence | undefined;
  purpose?:
    | Transaction_Purpose
    | undefined;
  /** Exchange rate that was valid when the transaction was sent. */
  exchangeRate?:
    | ExchangeRate
    | undefined;
  /**
   * Memo of the transaction. It can be used to record the memo of the payment request that initiated the
   * transaction.
   */
  memo?: string | undefined;
}

/**
 * This is a bitfield oriented enum, with the following bits:
 *
 * bit 0 - spent
 * bit 1 - appears in alt chain
 * bit 2 - appears in best chain
 * bit 3 - double-spent
 * bit 4 - pending (we would like the tx to go into the best chain)
 *
 * Not all combinations are interesting, just the ones actually used in the enum.
 */
export enum Transaction_Pool {
  /** UNSPENT - In best chain, not all outputs spent */
  UNSPENT = 4,
  /** SPENT - In best chain, all outputs spent */
  SPENT = 5,
  /** INACTIVE - In non-best chain, not our transaction */
  INACTIVE = 2,
  /** DEAD - Double-spent by a transaction in the best chain */
  DEAD = 10,
  /** PENDING - Our transaction, not in any chain */
  PENDING = 16,
  /** PENDING_INACTIVE - In non-best chain, our transaction */
  PENDING_INACTIVE = 18,
  UNRECOGNIZED = -1,
}

export function transaction_PoolFromJSON(object: any): Transaction_Pool {
  switch (object) {
    case 4:
    case "UNSPENT":
      return Transaction_Pool.UNSPENT;
    case 5:
    case "SPENT":
      return Transaction_Pool.SPENT;
    case 2:
    case "INACTIVE":
      return Transaction_Pool.INACTIVE;
    case 10:
    case "DEAD":
      return Transaction_Pool.DEAD;
    case 16:
    case "PENDING":
      return Transaction_Pool.PENDING;
    case 18:
    case "PENDING_INACTIVE":
      return Transaction_Pool.PENDING_INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_Pool.UNRECOGNIZED;
  }
}

export function transaction_PoolToJSON(object: Transaction_Pool): string {
  switch (object) {
    case Transaction_Pool.UNSPENT:
      return "UNSPENT";
    case Transaction_Pool.SPENT:
      return "SPENT";
    case Transaction_Pool.INACTIVE:
      return "INACTIVE";
    case Transaction_Pool.DEAD:
      return "DEAD";
    case Transaction_Pool.PENDING:
      return "PENDING";
    case Transaction_Pool.PENDING_INACTIVE:
      return "PENDING_INACTIVE";
    case Transaction_Pool.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For what purpose the transaction was created. */
export enum Transaction_Purpose {
  /** UNKNOWN - Old wallets or the purpose genuinely is a mystery (e.g. imported from some external source). */
  UNKNOWN = 0,
  /** USER_PAYMENT - Created in response to a user request for payment. This is the normal case. */
  USER_PAYMENT = 1,
  /** KEY_ROTATION - Created automatically to move money from rotated keys. */
  KEY_ROTATION = 2,
  /** ASSURANCE_CONTRACT_CLAIM - Stuff used by Lighthouse. */
  ASSURANCE_CONTRACT_CLAIM = 3,
  ASSURANCE_CONTRACT_PLEDGE = 4,
  ASSURANCE_CONTRACT_STUB = 5,
  /** RAISE_FEE - Raise fee, e.g. child-pays-for-parent. */
  RAISE_FEE = 6,
  UNRECOGNIZED = -1,
}

export function transaction_PurposeFromJSON(object: any): Transaction_Purpose {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Transaction_Purpose.UNKNOWN;
    case 1:
    case "USER_PAYMENT":
      return Transaction_Purpose.USER_PAYMENT;
    case 2:
    case "KEY_ROTATION":
      return Transaction_Purpose.KEY_ROTATION;
    case 3:
    case "ASSURANCE_CONTRACT_CLAIM":
      return Transaction_Purpose.ASSURANCE_CONTRACT_CLAIM;
    case 4:
    case "ASSURANCE_CONTRACT_PLEDGE":
      return Transaction_Purpose.ASSURANCE_CONTRACT_PLEDGE;
    case 5:
    case "ASSURANCE_CONTRACT_STUB":
      return Transaction_Purpose.ASSURANCE_CONTRACT_STUB;
    case 6:
    case "RAISE_FEE":
      return Transaction_Purpose.RAISE_FEE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_Purpose.UNRECOGNIZED;
  }
}

export function transaction_PurposeToJSON(object: Transaction_Purpose): string {
  switch (object) {
    case Transaction_Purpose.UNKNOWN:
      return "UNKNOWN";
    case Transaction_Purpose.USER_PAYMENT:
      return "USER_PAYMENT";
    case Transaction_Purpose.KEY_ROTATION:
      return "KEY_ROTATION";
    case Transaction_Purpose.ASSURANCE_CONTRACT_CLAIM:
      return "ASSURANCE_CONTRACT_CLAIM";
    case Transaction_Purpose.ASSURANCE_CONTRACT_PLEDGE:
      return "ASSURANCE_CONTRACT_PLEDGE";
    case Transaction_Purpose.ASSURANCE_CONTRACT_STUB:
      return "ASSURANCE_CONTRACT_STUB";
    case Transaction_Purpose.RAISE_FEE:
      return "RAISE_FEE";
    case Transaction_Purpose.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The parameters used in the scrypt key derivation function.
 *  The default values are taken from http://www.tarsnap.com/scrypt/scrypt-slides.pdf.
 *  They can be increased - n is the number of iterations performed and
 *  r and p can be used to tweak the algorithm - see:
 *  http://stackoverflow.com/questions/11126315/what-are-optimal-scrypt-work-factors
 */
export interface ScryptParameters {
  /** Salt to use in generation of the wallet password (8 bytes) */
  salt: Uint8Array;
  /** CPU/ memory cost parameter */
  n?:
    | number
    | undefined;
  /** Block size parameter */
  r?:
    | number
    | undefined;
  /** Parallelisation parameter */
  p?: number | undefined;
}

/** An extension to the wallet */
export interface Extension {
  /** like org.whatever.foo.bar */
  id: string;
  data: Uint8Array;
  /**
   * If we do not understand a mandatory extension, abort to prevent data loss.
   * For example, this could be applied to a new type of holding, such as a contract, where
   * dropping of an extension in a read/write cycle could cause loss of value.
   */
  mandatory: boolean;
}

/**
 * A simple key->value mapping that has no interpreted content at all. A bit like the extensions mechanism except
 * an extension is keyed by the ID of a piece of code that's loaded with the given data, and has the concept of
 * being mandatory if that code isn't found. Whereas this is just a blind key/value store.
 */
export interface Tag {
  tag: string;
  data: Uint8Array;
}

/** Data required to reconstruct TransactionSigner. */
export interface TransactionSigner {
  /** fully qualified class name of TransactionSigner implementation */
  className: string;
  /** arbitrary data required for signer to function */
  data?: Uint8Array | undefined;
}

/** A bitcoin wallet */
export interface Wallet {
  /** the network used by this wallet */
  networkIdentifier: string;
  /** The SHA256 hash of the head of the best chain seen by this wallet. */
  lastSeenBlockHash?:
    | Uint8Array
    | undefined;
  /** The height in the chain of the last seen block. */
  lastSeenBlockHeight?: number | undefined;
  lastSeenBlockTimeSecs?: number | undefined;
  key: Key[];
  transaction: Transaction[];
  watchedScript: Script[];
  encryptionType?: Wallet_EncryptionType | undefined;
  encryptionParameters?:
    | ScryptParameters
    | undefined;
  /**
   * The version number of the wallet - used to detect wallets that were produced in the future
   * (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
   * A version that's higher than the default is considered from the future.
   */
  version?: number | undefined;
  extension: Extension[];
  /** A UTF8 encoded text description of the wallet that is intended for end user provided text. */
  description?:
    | string
    | undefined;
  /**
   * UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
   * wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
   * can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
   */
  keyRotationTime?: number | undefined;
  tags: Tag[];
  /** transaction signers added to the wallet */
  transactionSigners: TransactionSigner[];
}

/**
 * The encryption type of the wallet.
 *
 * The encryption type is UNENCRYPTED for wallets where the wallet does not support encryption - wallets prior to
 * encryption support are grandfathered in as this wallet type.
 * When a wallet is ENCRYPTED_SCRYPT_AES the keys are either encrypted with the wallet password or are unencrypted.
 */
export enum Wallet_EncryptionType {
  /** UNENCRYPTED - All keys in the wallet are unencrypted */
  UNENCRYPTED = 1,
  /** ENCRYPTED_SCRYPT_AES - All keys are encrypted with a passphrase based KDF of scrypt and AES encryption */
  ENCRYPTED_SCRYPT_AES = 2,
  UNRECOGNIZED = -1,
}

export function wallet_EncryptionTypeFromJSON(object: any): Wallet_EncryptionType {
  switch (object) {
    case 1:
    case "UNENCRYPTED":
      return Wallet_EncryptionType.UNENCRYPTED;
    case 2:
    case "ENCRYPTED_SCRYPT_AES":
      return Wallet_EncryptionType.ENCRYPTED_SCRYPT_AES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Wallet_EncryptionType.UNRECOGNIZED;
  }
}

export function wallet_EncryptionTypeToJSON(object: Wallet_EncryptionType): string {
  switch (object) {
    case Wallet_EncryptionType.UNENCRYPTED:
      return "UNENCRYPTED";
    case Wallet_EncryptionType.ENCRYPTED_SCRYPT_AES:
      return "ENCRYPTED_SCRYPT_AES";
    case Wallet_EncryptionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An exchange rate between Bitcoin and some fiat currency. */
export interface ExchangeRate {
  /** This much of satoshis (1E-8 fractions)… */
  coinValue: number;
  /** …is worth this much of fiat (1E-4 fractions). */
  fiatValue: number;
  /** ISO 4217 currency code (if available) of the fiat currency. */
  fiatCurrencyCode: string;
}

function createBasePeerAddress(): PeerAddress {
  return { ipAddress: new Uint8Array(0), port: 0, services: 0 };
}

export const PeerAddress: MessageFns<PeerAddress> = {
  encode(message: PeerAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress.length !== 0) {
      writer.uint32(10).bytes(message.ipAddress);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.services !== 0) {
      writer.uint32(24).uint64(message.services);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.services = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerAddress {
    return {
      ipAddress: isSet(object.ipAddress) ? bytesFromBase64(object.ipAddress) : new Uint8Array(0),
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      services: isSet(object.services) ? globalThis.Number(object.services) : 0,
    };
  },

  toJSON(message: PeerAddress): unknown {
    const obj: any = {};
    if (message.ipAddress.length !== 0) {
      obj.ipAddress = base64FromBytes(message.ipAddress);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.services !== 0) {
      obj.services = Math.round(message.services);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerAddress>, I>>(base?: I): PeerAddress {
    return PeerAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerAddress>, I>>(object: I): PeerAddress {
    const message = createBasePeerAddress();
    message.ipAddress = object.ipAddress ?? new Uint8Array(0);
    message.port = object.port ?? 0;
    message.services = object.services ?? 0;
    return message;
  },
};

function createBaseEncryptedData(): EncryptedData {
  return { initialisationVector: new Uint8Array(0), encryptedPrivateKey: new Uint8Array(0) };
}

export const EncryptedData: MessageFns<EncryptedData> = {
  encode(message: EncryptedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialisationVector.length !== 0) {
      writer.uint32(10).bytes(message.initialisationVector);
    }
    if (message.encryptedPrivateKey.length !== 0) {
      writer.uint32(18).bytes(message.encryptedPrivateKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.initialisationVector = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encryptedPrivateKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedData {
    return {
      initialisationVector: isSet(object.initialisationVector)
        ? bytesFromBase64(object.initialisationVector)
        : new Uint8Array(0),
      encryptedPrivateKey: isSet(object.encryptedPrivateKey)
        ? bytesFromBase64(object.encryptedPrivateKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: EncryptedData): unknown {
    const obj: any = {};
    if (message.initialisationVector.length !== 0) {
      obj.initialisationVector = base64FromBytes(message.initialisationVector);
    }
    if (message.encryptedPrivateKey.length !== 0) {
      obj.encryptedPrivateKey = base64FromBytes(message.encryptedPrivateKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncryptedData>, I>>(base?: I): EncryptedData {
    return EncryptedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncryptedData>, I>>(object: I): EncryptedData {
    const message = createBaseEncryptedData();
    message.initialisationVector = object.initialisationVector ?? new Uint8Array(0);
    message.encryptedPrivateKey = object.encryptedPrivateKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeterministicKey(): DeterministicKey {
  return {
    chainCode: new Uint8Array(0),
    path: [],
    issuedSubkeys: 0,
    lookaheadSize: 0,
    isFollowing: false,
    sigsRequiredToSpend: 1,
  };
}

export const DeterministicKey: MessageFns<DeterministicKey> = {
  encode(message: DeterministicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainCode.length !== 0) {
      writer.uint32(10).bytes(message.chainCode);
    }
    writer.uint32(18).fork();
    for (const v of message.path) {
      writer.uint32(v);
    }
    writer.join();
    if (message.issuedSubkeys !== undefined && message.issuedSubkeys !== 0) {
      writer.uint32(24).uint32(message.issuedSubkeys);
    }
    if (message.lookaheadSize !== undefined && message.lookaheadSize !== 0) {
      writer.uint32(32).uint32(message.lookaheadSize);
    }
    if (message.isFollowing !== undefined && message.isFollowing !== false) {
      writer.uint32(40).bool(message.isFollowing);
    }
    if (message.sigsRequiredToSpend !== undefined && message.sigsRequiredToSpend !== 1) {
      writer.uint32(48).uint32(message.sigsRequiredToSpend);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeterministicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeterministicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainCode = reader.bytes();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.path.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.path.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.issuedSubkeys = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lookaheadSize = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isFollowing = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sigsRequiredToSpend = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeterministicKey {
    return {
      chainCode: isSet(object.chainCode) ? bytesFromBase64(object.chainCode) : new Uint8Array(0),
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.Number(e)) : [],
      issuedSubkeys: isSet(object.issuedSubkeys) ? globalThis.Number(object.issuedSubkeys) : 0,
      lookaheadSize: isSet(object.lookaheadSize) ? globalThis.Number(object.lookaheadSize) : 0,
      isFollowing: isSet(object.isFollowing) ? globalThis.Boolean(object.isFollowing) : false,
      sigsRequiredToSpend: isSet(object.sigsRequiredToSpend) ? globalThis.Number(object.sigsRequiredToSpend) : 1,
    };
  },

  toJSON(message: DeterministicKey): unknown {
    const obj: any = {};
    if (message.chainCode.length !== 0) {
      obj.chainCode = base64FromBytes(message.chainCode);
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => Math.round(e));
    }
    if (message.issuedSubkeys !== undefined && message.issuedSubkeys !== 0) {
      obj.issuedSubkeys = Math.round(message.issuedSubkeys);
    }
    if (message.lookaheadSize !== undefined && message.lookaheadSize !== 0) {
      obj.lookaheadSize = Math.round(message.lookaheadSize);
    }
    if (message.isFollowing !== undefined && message.isFollowing !== false) {
      obj.isFollowing = message.isFollowing;
    }
    if (message.sigsRequiredToSpend !== undefined && message.sigsRequiredToSpend !== 1) {
      obj.sigsRequiredToSpend = Math.round(message.sigsRequiredToSpend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeterministicKey>, I>>(base?: I): DeterministicKey {
    return DeterministicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeterministicKey>, I>>(object: I): DeterministicKey {
    const message = createBaseDeterministicKey();
    message.chainCode = object.chainCode ?? new Uint8Array(0);
    message.path = object.path?.map((e) => e) || [];
    message.issuedSubkeys = object.issuedSubkeys ?? 0;
    message.lookaheadSize = object.lookaheadSize ?? 0;
    message.isFollowing = object.isFollowing ?? false;
    message.sigsRequiredToSpend = object.sigsRequiredToSpend ?? 1;
    return message;
  },
};

function createBaseKey(): Key {
  return {
    type: 1,
    secretBytes: new Uint8Array(0),
    encryptedData: undefined,
    publicKey: new Uint8Array(0),
    label: "",
    creationTimestamp: 0,
    deterministicKey: undefined,
    deterministicSeed: new Uint8Array(0),
    encryptedDeterministicSeed: undefined,
  };
}

export const Key: MessageFns<Key> = {
  encode(message: Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 1) {
      writer.uint32(8).int32(message.type);
    }
    if (message.secretBytes !== undefined && message.secretBytes.length !== 0) {
      writer.uint32(18).bytes(message.secretBytes);
    }
    if (message.encryptedData !== undefined) {
      EncryptedData.encode(message.encryptedData, writer.uint32(50).fork()).join();
    }
    if (message.publicKey !== undefined && message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    if (message.label !== undefined && message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.creationTimestamp !== undefined && message.creationTimestamp !== 0) {
      writer.uint32(40).int64(message.creationTimestamp);
    }
    if (message.deterministicKey !== undefined) {
      DeterministicKey.encode(message.deterministicKey, writer.uint32(58).fork()).join();
    }
    if (message.deterministicSeed !== undefined && message.deterministicSeed.length !== 0) {
      writer.uint32(66).bytes(message.deterministicSeed);
    }
    if (message.encryptedDeterministicSeed !== undefined) {
      EncryptedData.encode(message.encryptedDeterministicSeed, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretBytes = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encryptedData = EncryptedData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.creationTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deterministicKey = DeterministicKey.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deterministicSeed = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.encryptedDeterministicSeed = EncryptedData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key {
    return {
      type: isSet(object.type) ? key_TypeFromJSON(object.type) : 1,
      secretBytes: isSet(object.secretBytes) ? bytesFromBase64(object.secretBytes) : new Uint8Array(0),
      encryptedData: isSet(object.encryptedData) ? EncryptedData.fromJSON(object.encryptedData) : undefined,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      creationTimestamp: isSet(object.creationTimestamp) ? globalThis.Number(object.creationTimestamp) : 0,
      deterministicKey: isSet(object.deterministicKey) ? DeterministicKey.fromJSON(object.deterministicKey) : undefined,
      deterministicSeed: isSet(object.deterministicSeed)
        ? bytesFromBase64(object.deterministicSeed)
        : new Uint8Array(0),
      encryptedDeterministicSeed: isSet(object.encryptedDeterministicSeed)
        ? EncryptedData.fromJSON(object.encryptedDeterministicSeed)
        : undefined,
    };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.type !== 1) {
      obj.type = key_TypeToJSON(message.type);
    }
    if (message.secretBytes !== undefined && message.secretBytes.length !== 0) {
      obj.secretBytes = base64FromBytes(message.secretBytes);
    }
    if (message.encryptedData !== undefined) {
      obj.encryptedData = EncryptedData.toJSON(message.encryptedData);
    }
    if (message.publicKey !== undefined && message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.label !== undefined && message.label !== "") {
      obj.label = message.label;
    }
    if (message.creationTimestamp !== undefined && message.creationTimestamp !== 0) {
      obj.creationTimestamp = Math.round(message.creationTimestamp);
    }
    if (message.deterministicKey !== undefined) {
      obj.deterministicKey = DeterministicKey.toJSON(message.deterministicKey);
    }
    if (message.deterministicSeed !== undefined && message.deterministicSeed.length !== 0) {
      obj.deterministicSeed = base64FromBytes(message.deterministicSeed);
    }
    if (message.encryptedDeterministicSeed !== undefined) {
      obj.encryptedDeterministicSeed = EncryptedData.toJSON(message.encryptedDeterministicSeed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Key>, I>>(base?: I): Key {
    return Key.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Key>, I>>(object: I): Key {
    const message = createBaseKey();
    message.type = object.type ?? 1;
    message.secretBytes = object.secretBytes ?? new Uint8Array(0);
    message.encryptedData = (object.encryptedData !== undefined && object.encryptedData !== null)
      ? EncryptedData.fromPartial(object.encryptedData)
      : undefined;
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.label = object.label ?? "";
    message.creationTimestamp = object.creationTimestamp ?? 0;
    message.deterministicKey = (object.deterministicKey !== undefined && object.deterministicKey !== null)
      ? DeterministicKey.fromPartial(object.deterministicKey)
      : undefined;
    message.deterministicSeed = object.deterministicSeed ?? new Uint8Array(0);
    message.encryptedDeterministicSeed =
      (object.encryptedDeterministicSeed !== undefined && object.encryptedDeterministicSeed !== null)
        ? EncryptedData.fromPartial(object.encryptedDeterministicSeed)
        : undefined;
    return message;
  },
};

function createBaseScript(): Script {
  return { program: new Uint8Array(0), creationTimestamp: 0 };
}

export const Script: MessageFns<Script> = {
  encode(message: Script, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program.length !== 0) {
      writer.uint32(10).bytes(message.program);
    }
    if (message.creationTimestamp !== 0) {
      writer.uint32(16).int64(message.creationTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Script {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.program = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.creationTimestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Script {
    return {
      program: isSet(object.program) ? bytesFromBase64(object.program) : new Uint8Array(0),
      creationTimestamp: isSet(object.creationTimestamp) ? globalThis.Number(object.creationTimestamp) : 0,
    };
  },

  toJSON(message: Script): unknown {
    const obj: any = {};
    if (message.program.length !== 0) {
      obj.program = base64FromBytes(message.program);
    }
    if (message.creationTimestamp !== 0) {
      obj.creationTimestamp = Math.round(message.creationTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Script>, I>>(base?: I): Script {
    return Script.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Script>, I>>(object: I): Script {
    const message = createBaseScript();
    message.program = object.program ?? new Uint8Array(0);
    message.creationTimestamp = object.creationTimestamp ?? 0;
    return message;
  },
};

function createBaseTransactionInput(): TransactionInput {
  return {
    transactionOutPointHash: new Uint8Array(0),
    transactionOutPointIndex: 0,
    scriptBytes: new Uint8Array(0),
    sequence: 0,
    value: 0,
  };
}

export const TransactionInput: MessageFns<TransactionInput> = {
  encode(message: TransactionInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionOutPointHash.length !== 0) {
      writer.uint32(10).bytes(message.transactionOutPointHash);
    }
    if (message.transactionOutPointIndex !== 0) {
      writer.uint32(16).uint32(message.transactionOutPointIndex);
    }
    if (message.scriptBytes.length !== 0) {
      writer.uint32(26).bytes(message.scriptBytes);
    }
    if (message.sequence !== undefined && message.sequence !== 0) {
      writer.uint32(32).uint32(message.sequence);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(40).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionOutPointHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transactionOutPointIndex = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scriptBytes = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sequence = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.value = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInput {
    return {
      transactionOutPointHash: isSet(object.transactionOutPointHash)
        ? bytesFromBase64(object.transactionOutPointHash)
        : new Uint8Array(0),
      transactionOutPointIndex: isSet(object.transactionOutPointIndex)
        ? globalThis.Number(object.transactionOutPointIndex)
        : 0,
      scriptBytes: isSet(object.scriptBytes) ? bytesFromBase64(object.scriptBytes) : new Uint8Array(0),
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: TransactionInput): unknown {
    const obj: any = {};
    if (message.transactionOutPointHash.length !== 0) {
      obj.transactionOutPointHash = base64FromBytes(message.transactionOutPointHash);
    }
    if (message.transactionOutPointIndex !== 0) {
      obj.transactionOutPointIndex = Math.round(message.transactionOutPointIndex);
    }
    if (message.scriptBytes.length !== 0) {
      obj.scriptBytes = base64FromBytes(message.scriptBytes);
    }
    if (message.sequence !== undefined && message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInput>, I>>(base?: I): TransactionInput {
    return TransactionInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInput>, I>>(object: I): TransactionInput {
    const message = createBaseTransactionInput();
    message.transactionOutPointHash = object.transactionOutPointHash ?? new Uint8Array(0);
    message.transactionOutPointIndex = object.transactionOutPointIndex ?? 0;
    message.scriptBytes = object.scriptBytes ?? new Uint8Array(0);
    message.sequence = object.sequence ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseTransactionOutput(): TransactionOutput {
  return {
    value: 0,
    tokenid: 0,
    scriptBytes: new Uint8Array(0),
    spentByTransactionHash: new Uint8Array(0),
    spentByTransactionIndex: 0,
  };
}

export const TransactionOutput: MessageFns<TransactionOutput> = {
  encode(message: TransactionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int64(message.value);
    }
    if (message.tokenid !== 0) {
      writer.uint32(16).int64(message.tokenid);
    }
    if (message.scriptBytes.length !== 0) {
      writer.uint32(26).bytes(message.scriptBytes);
    }
    if (message.spentByTransactionHash !== undefined && message.spentByTransactionHash.length !== 0) {
      writer.uint32(34).bytes(message.spentByTransactionHash);
    }
    if (message.spentByTransactionIndex !== undefined && message.spentByTransactionIndex !== 0) {
      writer.uint32(40).int32(message.spentByTransactionIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tokenid = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scriptBytes = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.spentByTransactionHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.spentByTransactionIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionOutput {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      tokenid: isSet(object.tokenid) ? globalThis.Number(object.tokenid) : 0,
      scriptBytes: isSet(object.scriptBytes) ? bytesFromBase64(object.scriptBytes) : new Uint8Array(0),
      spentByTransactionHash: isSet(object.spentByTransactionHash)
        ? bytesFromBase64(object.spentByTransactionHash)
        : new Uint8Array(0),
      spentByTransactionIndex: isSet(object.spentByTransactionIndex)
        ? globalThis.Number(object.spentByTransactionIndex)
        : 0,
    };
  },

  toJSON(message: TransactionOutput): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.tokenid !== 0) {
      obj.tokenid = Math.round(message.tokenid);
    }
    if (message.scriptBytes.length !== 0) {
      obj.scriptBytes = base64FromBytes(message.scriptBytes);
    }
    if (message.spentByTransactionHash !== undefined && message.spentByTransactionHash.length !== 0) {
      obj.spentByTransactionHash = base64FromBytes(message.spentByTransactionHash);
    }
    if (message.spentByTransactionIndex !== undefined && message.spentByTransactionIndex !== 0) {
      obj.spentByTransactionIndex = Math.round(message.spentByTransactionIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionOutput>, I>>(base?: I): TransactionOutput {
    return TransactionOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionOutput>, I>>(object: I): TransactionOutput {
    const message = createBaseTransactionOutput();
    message.value = object.value ?? 0;
    message.tokenid = object.tokenid ?? 0;
    message.scriptBytes = object.scriptBytes ?? new Uint8Array(0);
    message.spentByTransactionHash = object.spentByTransactionHash ?? new Uint8Array(0);
    message.spentByTransactionIndex = object.spentByTransactionIndex ?? 0;
    return message;
  },
};

function createBaseTransactionConfidence(): TransactionConfidence {
  return {
    type: 0,
    appearedAtHeight: 0,
    overridingTransaction: new Uint8Array(0),
    depth: 0,
    broadcastBy: [],
    lastBroadcastedAt: 0,
    source: 0,
  };
}

export const TransactionConfidence: MessageFns<TransactionConfidence> = {
  encode(message: TransactionConfidence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.appearedAtHeight !== undefined && message.appearedAtHeight !== 0) {
      writer.uint32(16).int32(message.appearedAtHeight);
    }
    if (message.overridingTransaction !== undefined && message.overridingTransaction.length !== 0) {
      writer.uint32(26).bytes(message.overridingTransaction);
    }
    if (message.depth !== undefined && message.depth !== 0) {
      writer.uint32(32).int32(message.depth);
    }
    for (const v of message.broadcastBy) {
      PeerAddress.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.lastBroadcastedAt !== undefined && message.lastBroadcastedAt !== 0) {
      writer.uint32(64).int64(message.lastBroadcastedAt);
    }
    if (message.source !== undefined && message.source !== 0) {
      writer.uint32(56).int32(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionConfidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionConfidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.appearedAtHeight = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.overridingTransaction = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.broadcastBy.push(PeerAddress.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.lastBroadcastedAt = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionConfidence {
    return {
      type: isSet(object.type) ? transactionConfidence_TypeFromJSON(object.type) : 0,
      appearedAtHeight: isSet(object.appearedAtHeight) ? globalThis.Number(object.appearedAtHeight) : 0,
      overridingTransaction: isSet(object.overridingTransaction)
        ? bytesFromBase64(object.overridingTransaction)
        : new Uint8Array(0),
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
      broadcastBy: globalThis.Array.isArray(object?.broadcastBy)
        ? object.broadcastBy.map((e: any) => PeerAddress.fromJSON(e))
        : [],
      lastBroadcastedAt: isSet(object.lastBroadcastedAt) ? globalThis.Number(object.lastBroadcastedAt) : 0,
      source: isSet(object.source) ? transactionConfidence_SourceFromJSON(object.source) : 0,
    };
  },

  toJSON(message: TransactionConfidence): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = transactionConfidence_TypeToJSON(message.type);
    }
    if (message.appearedAtHeight !== undefined && message.appearedAtHeight !== 0) {
      obj.appearedAtHeight = Math.round(message.appearedAtHeight);
    }
    if (message.overridingTransaction !== undefined && message.overridingTransaction.length !== 0) {
      obj.overridingTransaction = base64FromBytes(message.overridingTransaction);
    }
    if (message.depth !== undefined && message.depth !== 0) {
      obj.depth = Math.round(message.depth);
    }
    if (message.broadcastBy?.length) {
      obj.broadcastBy = message.broadcastBy.map((e) => PeerAddress.toJSON(e));
    }
    if (message.lastBroadcastedAt !== undefined && message.lastBroadcastedAt !== 0) {
      obj.lastBroadcastedAt = Math.round(message.lastBroadcastedAt);
    }
    if (message.source !== undefined && message.source !== 0) {
      obj.source = transactionConfidence_SourceToJSON(message.source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionConfidence>, I>>(base?: I): TransactionConfidence {
    return TransactionConfidence.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionConfidence>, I>>(object: I): TransactionConfidence {
    const message = createBaseTransactionConfidence();
    message.type = object.type ?? 0;
    message.appearedAtHeight = object.appearedAtHeight ?? 0;
    message.overridingTransaction = object.overridingTransaction ?? new Uint8Array(0);
    message.depth = object.depth ?? 0;
    message.broadcastBy = object.broadcastBy?.map((e) => PeerAddress.fromPartial(e)) || [];
    message.lastBroadcastedAt = object.lastBroadcastedAt ?? 0;
    message.source = object.source ?? 0;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    version: 0,
    hash: new Uint8Array(0),
    pool: 4,
    lockTime: 0,
    updatedAt: 0,
    transactionInput: [],
    transactionOutput: [],
    blockHash: [],
    blockRelativityOffsets: [],
    confidence: undefined,
    purpose: 0,
    exchangeRate: undefined,
    memo: "",
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.pool !== undefined && message.pool !== 4) {
      writer.uint32(24).int32(message.pool);
    }
    if (message.lockTime !== undefined && message.lockTime !== 0) {
      writer.uint32(32).uint32(message.lockTime);
    }
    if (message.updatedAt !== undefined && message.updatedAt !== 0) {
      writer.uint32(40).int64(message.updatedAt);
    }
    for (const v of message.transactionInput) {
      TransactionInput.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.transactionOutput) {
      TransactionOutput.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.blockHash) {
      writer.uint32(66).bytes(v!);
    }
    writer.uint32(90).fork();
    for (const v of message.blockRelativityOffsets) {
      writer.int32(v);
    }
    writer.join();
    if (message.confidence !== undefined) {
      TransactionConfidence.encode(message.confidence, writer.uint32(74).fork()).join();
    }
    if (message.purpose !== undefined && message.purpose !== 0) {
      writer.uint32(80).int32(message.purpose);
    }
    if (message.exchangeRate !== undefined) {
      ExchangeRate.encode(message.exchangeRate, writer.uint32(98).fork()).join();
    }
    if (message.memo !== undefined && message.memo !== "") {
      writer.uint32(106).string(message.memo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pool = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lockTime = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transactionInput.push(TransactionInput.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.transactionOutput.push(TransactionOutput.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.blockHash.push(reader.bytes());
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.blockRelativityOffsets.push(reader.int32());

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.blockRelativityOffsets.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.confidence = TransactionConfidence.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.purpose = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.exchangeRate = ExchangeRate.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      pool: isSet(object.pool) ? transaction_PoolFromJSON(object.pool) : 4,
      lockTime: isSet(object.lockTime) ? globalThis.Number(object.lockTime) : 0,
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
      transactionInput: globalThis.Array.isArray(object?.transactionInput)
        ? object.transactionInput.map((e: any) => TransactionInput.fromJSON(e))
        : [],
      transactionOutput: globalThis.Array.isArray(object?.transactionOutput)
        ? object.transactionOutput.map((e: any) => TransactionOutput.fromJSON(e))
        : [],
      blockHash: globalThis.Array.isArray(object?.blockHash)
        ? object.blockHash.map((e: any) => bytesFromBase64(e))
        : [],
      blockRelativityOffsets: globalThis.Array.isArray(object?.blockRelativityOffsets)
        ? object.blockRelativityOffsets.map((e: any) => globalThis.Number(e))
        : [],
      confidence: isSet(object.confidence) ? TransactionConfidence.fromJSON(object.confidence) : undefined,
      purpose: isSet(object.purpose) ? transaction_PurposeFromJSON(object.purpose) : 0,
      exchangeRate: isSet(object.exchangeRate) ? ExchangeRate.fromJSON(object.exchangeRate) : undefined,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.pool !== undefined && message.pool !== 4) {
      obj.pool = transaction_PoolToJSON(message.pool);
    }
    if (message.lockTime !== undefined && message.lockTime !== 0) {
      obj.lockTime = Math.round(message.lockTime);
    }
    if (message.updatedAt !== undefined && message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    if (message.transactionInput?.length) {
      obj.transactionInput = message.transactionInput.map((e) => TransactionInput.toJSON(e));
    }
    if (message.transactionOutput?.length) {
      obj.transactionOutput = message.transactionOutput.map((e) => TransactionOutput.toJSON(e));
    }
    if (message.blockHash?.length) {
      obj.blockHash = message.blockHash.map((e) => base64FromBytes(e));
    }
    if (message.blockRelativityOffsets?.length) {
      obj.blockRelativityOffsets = message.blockRelativityOffsets.map((e) => Math.round(e));
    }
    if (message.confidence !== undefined) {
      obj.confidence = TransactionConfidence.toJSON(message.confidence);
    }
    if (message.purpose !== undefined && message.purpose !== 0) {
      obj.purpose = transaction_PurposeToJSON(message.purpose);
    }
    if (message.exchangeRate !== undefined) {
      obj.exchangeRate = ExchangeRate.toJSON(message.exchangeRate);
    }
    if (message.memo !== undefined && message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.version = object.version ?? 0;
    message.hash = object.hash ?? new Uint8Array(0);
    message.pool = object.pool ?? 4;
    message.lockTime = object.lockTime ?? 0;
    message.updatedAt = object.updatedAt ?? 0;
    message.transactionInput = object.transactionInput?.map((e) => TransactionInput.fromPartial(e)) || [];
    message.transactionOutput = object.transactionOutput?.map((e) => TransactionOutput.fromPartial(e)) || [];
    message.blockHash = object.blockHash?.map((e) => e) || [];
    message.blockRelativityOffsets = object.blockRelativityOffsets?.map((e) => e) || [];
    message.confidence = (object.confidence !== undefined && object.confidence !== null)
      ? TransactionConfidence.fromPartial(object.confidence)
      : undefined;
    message.purpose = object.purpose ?? 0;
    message.exchangeRate = (object.exchangeRate !== undefined && object.exchangeRate !== null)
      ? ExchangeRate.fromPartial(object.exchangeRate)
      : undefined;
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseScryptParameters(): ScryptParameters {
  return { salt: new Uint8Array(0), n: 16384, r: 8, p: 1 };
}

export const ScryptParameters: MessageFns<ScryptParameters> = {
  encode(message: ScryptParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.salt.length !== 0) {
      writer.uint32(10).bytes(message.salt);
    }
    if (message.n !== undefined && message.n !== 16384) {
      writer.uint32(16).int64(message.n);
    }
    if (message.r !== undefined && message.r !== 8) {
      writer.uint32(24).int32(message.r);
    }
    if (message.p !== undefined && message.p !== 1) {
      writer.uint32(32).int32(message.p);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScryptParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScryptParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.salt = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.n = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.r = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.p = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScryptParameters {
    return {
      salt: isSet(object.salt) ? bytesFromBase64(object.salt) : new Uint8Array(0),
      n: isSet(object.n) ? globalThis.Number(object.n) : 16384,
      r: isSet(object.r) ? globalThis.Number(object.r) : 8,
      p: isSet(object.p) ? globalThis.Number(object.p) : 1,
    };
  },

  toJSON(message: ScryptParameters): unknown {
    const obj: any = {};
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    if (message.n !== undefined && message.n !== 16384) {
      obj.n = Math.round(message.n);
    }
    if (message.r !== undefined && message.r !== 8) {
      obj.r = Math.round(message.r);
    }
    if (message.p !== undefined && message.p !== 1) {
      obj.p = Math.round(message.p);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScryptParameters>, I>>(base?: I): ScryptParameters {
    return ScryptParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScryptParameters>, I>>(object: I): ScryptParameters {
    const message = createBaseScryptParameters();
    message.salt = object.salt ?? new Uint8Array(0);
    message.n = object.n ?? 16384;
    message.r = object.r ?? 8;
    message.p = object.p ?? 1;
    return message;
  },
};

function createBaseExtension(): Extension {
  return { id: "", data: new Uint8Array(0), mandatory: false };
}

export const Extension: MessageFns<Extension> = {
  encode(message: Extension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.mandatory !== false) {
      writer.uint32(24).bool(message.mandatory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Extension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mandatory = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Extension {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      mandatory: isSet(object.mandatory) ? globalThis.Boolean(object.mandatory) : false,
    };
  },

  toJSON(message: Extension): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.mandatory !== false) {
      obj.mandatory = message.mandatory;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Extension>, I>>(base?: I): Extension {
    return Extension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Extension>, I>>(object: I): Extension {
    const message = createBaseExtension();
    message.id = object.id ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.mandatory = object.mandatory ?? false;
    return message;
  },
};

function createBaseTag(): Tag {
  return { tag: "", data: new Uint8Array(0) };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag>, I>>(base?: I): Tag {
    return Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag>, I>>(object: I): Tag {
    const message = createBaseTag();
    message.tag = object.tag ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransactionSigner(): TransactionSigner {
  return { className: "", data: new Uint8Array(0) };
}

export const TransactionSigner: MessageFns<TransactionSigner> = {
  encode(message: TransactionSigner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.className !== "") {
      writer.uint32(10).string(message.className);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionSigner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.className = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionSigner {
    return {
      className: isSet(object.className) ? globalThis.String(object.className) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: TransactionSigner): unknown {
    const obj: any = {};
    if (message.className !== "") {
      obj.className = message.className;
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionSigner>, I>>(base?: I): TransactionSigner {
    return TransactionSigner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionSigner>, I>>(object: I): TransactionSigner {
    const message = createBaseTransactionSigner();
    message.className = object.className ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWallet(): Wallet {
  return {
    networkIdentifier: "",
    lastSeenBlockHash: new Uint8Array(0),
    lastSeenBlockHeight: 0,
    lastSeenBlockTimeSecs: 0,
    key: [],
    transaction: [],
    watchedScript: [],
    encryptionType: 1,
    encryptionParameters: undefined,
    version: 1,
    extension: [],
    description: "",
    keyRotationTime: 0,
    tags: [],
    transactionSigners: [],
  };
}

export const Wallet: MessageFns<Wallet> = {
  encode(message: Wallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkIdentifier !== "") {
      writer.uint32(10).string(message.networkIdentifier);
    }
    if (message.lastSeenBlockHash !== undefined && message.lastSeenBlockHash.length !== 0) {
      writer.uint32(18).bytes(message.lastSeenBlockHash);
    }
    if (message.lastSeenBlockHeight !== undefined && message.lastSeenBlockHeight !== 0) {
      writer.uint32(96).uint32(message.lastSeenBlockHeight);
    }
    if (message.lastSeenBlockTimeSecs !== undefined && message.lastSeenBlockTimeSecs !== 0) {
      writer.uint32(112).int64(message.lastSeenBlockTimeSecs);
    }
    for (const v of message.key) {
      Key.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.transaction) {
      Transaction.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.watchedScript) {
      Script.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.encryptionType !== undefined && message.encryptionType !== 1) {
      writer.uint32(40).int32(message.encryptionType);
    }
    if (message.encryptionParameters !== undefined) {
      ScryptParameters.encode(message.encryptionParameters, writer.uint32(50).fork()).join();
    }
    if (message.version !== undefined && message.version !== 1) {
      writer.uint32(56).int32(message.version);
    }
    for (const v of message.extension) {
      Extension.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.keyRotationTime !== undefined && message.keyRotationTime !== 0) {
      writer.uint32(104).uint64(message.keyRotationTime);
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.transactionSigners) {
      TransactionSigner.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.networkIdentifier = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastSeenBlockHash = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.lastSeenBlockHeight = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.lastSeenBlockTimeSecs = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key.push(Key.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transaction.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.watchedScript.push(Script.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.encryptionType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encryptionParameters = ScryptParameters.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.extension.push(Extension.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.keyRotationTime = longToNumber(reader.uint64());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.transactionSigners.push(TransactionSigner.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wallet {
    return {
      networkIdentifier: isSet(object.networkIdentifier) ? globalThis.String(object.networkIdentifier) : "",
      lastSeenBlockHash: isSet(object.lastSeenBlockHash)
        ? bytesFromBase64(object.lastSeenBlockHash)
        : new Uint8Array(0),
      lastSeenBlockHeight: isSet(object.lastSeenBlockHeight) ? globalThis.Number(object.lastSeenBlockHeight) : 0,
      lastSeenBlockTimeSecs: isSet(object.lastSeenBlockTimeSecs) ? globalThis.Number(object.lastSeenBlockTimeSecs) : 0,
      key: globalThis.Array.isArray(object?.key) ? object.key.map((e: any) => Key.fromJSON(e)) : [],
      transaction: globalThis.Array.isArray(object?.transaction)
        ? object.transaction.map((e: any) => Transaction.fromJSON(e))
        : [],
      watchedScript: globalThis.Array.isArray(object?.watchedScript)
        ? object.watchedScript.map((e: any) => Script.fromJSON(e))
        : [],
      encryptionType: isSet(object.encryptionType) ? wallet_EncryptionTypeFromJSON(object.encryptionType) : 1,
      encryptionParameters: isSet(object.encryptionParameters)
        ? ScryptParameters.fromJSON(object.encryptionParameters)
        : undefined,
      version: isSet(object.version) ? globalThis.Number(object.version) : 1,
      extension: globalThis.Array.isArray(object?.extension)
        ? object.extension.map((e: any) => Extension.fromJSON(e))
        : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      keyRotationTime: isSet(object.keyRotationTime) ? globalThis.Number(object.keyRotationTime) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Tag.fromJSON(e)) : [],
      transactionSigners: globalThis.Array.isArray(object?.transactionSigners)
        ? object.transactionSigners.map((e: any) => TransactionSigner.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Wallet): unknown {
    const obj: any = {};
    if (message.networkIdentifier !== "") {
      obj.networkIdentifier = message.networkIdentifier;
    }
    if (message.lastSeenBlockHash !== undefined && message.lastSeenBlockHash.length !== 0) {
      obj.lastSeenBlockHash = base64FromBytes(message.lastSeenBlockHash);
    }
    if (message.lastSeenBlockHeight !== undefined && message.lastSeenBlockHeight !== 0) {
      obj.lastSeenBlockHeight = Math.round(message.lastSeenBlockHeight);
    }
    if (message.lastSeenBlockTimeSecs !== undefined && message.lastSeenBlockTimeSecs !== 0) {
      obj.lastSeenBlockTimeSecs = Math.round(message.lastSeenBlockTimeSecs);
    }
    if (message.key?.length) {
      obj.key = message.key.map((e) => Key.toJSON(e));
    }
    if (message.transaction?.length) {
      obj.transaction = message.transaction.map((e) => Transaction.toJSON(e));
    }
    if (message.watchedScript?.length) {
      obj.watchedScript = message.watchedScript.map((e) => Script.toJSON(e));
    }
    if (message.encryptionType !== undefined && message.encryptionType !== 1) {
      obj.encryptionType = wallet_EncryptionTypeToJSON(message.encryptionType);
    }
    if (message.encryptionParameters !== undefined) {
      obj.encryptionParameters = ScryptParameters.toJSON(message.encryptionParameters);
    }
    if (message.version !== undefined && message.version !== 1) {
      obj.version = Math.round(message.version);
    }
    if (message.extension?.length) {
      obj.extension = message.extension.map((e) => Extension.toJSON(e));
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    if (message.keyRotationTime !== undefined && message.keyRotationTime !== 0) {
      obj.keyRotationTime = Math.round(message.keyRotationTime);
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.transactionSigners?.length) {
      obj.transactionSigners = message.transactionSigners.map((e) => TransactionSigner.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wallet>, I>>(base?: I): Wallet {
    return Wallet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wallet>, I>>(object: I): Wallet {
    const message = createBaseWallet();
    message.networkIdentifier = object.networkIdentifier ?? "";
    message.lastSeenBlockHash = object.lastSeenBlockHash ?? new Uint8Array(0);
    message.lastSeenBlockHeight = object.lastSeenBlockHeight ?? 0;
    message.lastSeenBlockTimeSecs = object.lastSeenBlockTimeSecs ?? 0;
    message.key = object.key?.map((e) => Key.fromPartial(e)) || [];
    message.transaction = object.transaction?.map((e) => Transaction.fromPartial(e)) || [];
    message.watchedScript = object.watchedScript?.map((e) => Script.fromPartial(e)) || [];
    message.encryptionType = object.encryptionType ?? 1;
    message.encryptionParameters = (object.encryptionParameters !== undefined && object.encryptionParameters !== null)
      ? ScryptParameters.fromPartial(object.encryptionParameters)
      : undefined;
    message.version = object.version ?? 1;
    message.extension = object.extension?.map((e) => Extension.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.keyRotationTime = object.keyRotationTime ?? 0;
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.transactionSigners = object.transactionSigners?.map((e) => TransactionSigner.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExchangeRate(): ExchangeRate {
  return { coinValue: 0, fiatValue: 0, fiatCurrencyCode: "" };
}

export const ExchangeRate: MessageFns<ExchangeRate> = {
  encode(message: ExchangeRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coinValue !== 0) {
      writer.uint32(8).int64(message.coinValue);
    }
    if (message.fiatValue !== 0) {
      writer.uint32(16).int64(message.fiatValue);
    }
    if (message.fiatCurrencyCode !== "") {
      writer.uint32(26).string(message.fiatCurrencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinValue = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fiatValue = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fiatCurrencyCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeRate {
    return {
      coinValue: isSet(object.coinValue) ? globalThis.Number(object.coinValue) : 0,
      fiatValue: isSet(object.fiatValue) ? globalThis.Number(object.fiatValue) : 0,
      fiatCurrencyCode: isSet(object.fiatCurrencyCode) ? globalThis.String(object.fiatCurrencyCode) : "",
    };
  },

  toJSON(message: ExchangeRate): unknown {
    const obj: any = {};
    if (message.coinValue !== 0) {
      obj.coinValue = Math.round(message.coinValue);
    }
    if (message.fiatValue !== 0) {
      obj.fiatValue = Math.round(message.fiatValue);
    }
    if (message.fiatCurrencyCode !== "") {
      obj.fiatCurrencyCode = message.fiatCurrencyCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeRate>, I>>(base?: I): ExchangeRate {
    return ExchangeRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeRate>, I>>(object: I): ExchangeRate {
    const message = createBaseExchangeRate();
    message.coinValue = object.coinValue ?? 0;
    message.fiatValue = object.fiatValue ?? 0;
    message.fiatCurrencyCode = object.fiatCurrencyCode ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
